// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "PushService.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Apple { public struct Apns { }}

public extension Apple.Apns {
  public struct PushServiceRoot {
    public static let `default` = PushServiceRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  final public class ProviderData : GeneratedMessage {

    public static func == (lhs: Apple.Apns.ProviderData, rhs: Apple.Apns.ProviderData) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasBundle == rhs.hasBundle) && (!lhs.hasBundle || lhs.bundle == rhs.bundle)
      fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
      fieldCheck = fieldCheck && (lhs.hasPriority == rhs.hasPriority) && (!lhs.hasPriority || lhs.priority == rhs.priority)
      fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
      fieldCheck = fieldCheck && (lhs.hasServiceIdentity == rhs.hasServiceIdentity) && (!lhs.hasServiceIdentity || lhs.serviceIdentity == rhs.serviceIdentity)
      fieldCheck = fieldCheck && (lhs.hasCertificatePath == rhs.hasCertificatePath) && (!lhs.hasCertificatePath || lhs.certificatePath == rhs.certificatePath)
      fieldCheck = fieldCheck && (lhs.hasCertificatePassphrase == rhs.hasCertificatePassphrase) && (!lhs.hasCertificatePassphrase || lhs.certificatePassphrase == rhs.certificatePassphrase)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Identity:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case production = 0
        case development = 1
        public func toString() -> String {
          switch self {
          case .production: return "Production"
          case .development: return "Development"
          }
        }
        public static func fromString(str:String) throws -> Apple.Apns.ProviderData.Identity {
          switch str {
          case "Production":  return .production
          case "Development":  return .development
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .production: return ".production"
          case .development: return ".development"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var bundle:String = ""
    public fileprivate(set) var hasBundle:Bool = false

    public fileprivate(set) var token:String = ""
    public fileprivate(set) var hasToken:Bool = false

    public fileprivate(set) var priority:UInt32 = UInt32(0)
    public fileprivate(set) var hasPriority:Bool = false

    public fileprivate(set) var payload:Apple.Apns.Push!
    public fileprivate(set) var hasPayload:Bool = false
    public fileprivate(set) var serviceIdentity:Apple.Apns.ProviderData.Identity = Apple.Apns.ProviderData.Identity.production
    public fileprivate(set) var hasServiceIdentity:Bool = false
    public fileprivate(set) var certificatePath:String = ""
    public fileprivate(set) var hasCertificatePath:Bool = false

    public fileprivate(set) var certificatePassphrase:String = ""
    public fileprivate(set) var hasCertificatePassphrase:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasBundle {
        try codedOutputStream.writeString(fieldNumber: 1, value:bundle)
      }
      if hasToken {
        try codedOutputStream.writeString(fieldNumber: 2, value:token)
      }
      if hasPriority {
        try codedOutputStream.writeUInt32(fieldNumber: 3, value:priority)
      }
      if hasPayload {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:payload)
      }
      if hasServiceIdentity {
        try codedOutputStream.writeEnum(fieldNumber: 5, value:serviceIdentity.rawValue)
      }
      if hasCertificatePath {
        try codedOutputStream.writeString(fieldNumber: 6, value:certificatePath)
      }
      if hasCertificatePassphrase {
        try codedOutputStream.writeString(fieldNumber: 7, value:certificatePassphrase)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasBundle {
        serialize_size += bundle.computeStringSize(fieldNumber: 1)
      }
      if hasToken {
        serialize_size += token.computeStringSize(fieldNumber: 2)
      }
      if hasPriority {
        serialize_size += priority.computeUInt32Size(fieldNumber: 3)
      }
      if hasPayload {
          if let varSizepayload = payload?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizepayload
          }
      }
      if (hasServiceIdentity) {
        serialize_size += serviceIdentity.rawValue.computeEnumSize(fieldNumber: 5)
      }
      if hasCertificatePath {
        serialize_size += certificatePath.computeStringSize(fieldNumber: 6)
      }
      if hasCertificatePassphrase {
        serialize_size += certificatePassphrase.computeStringSize(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Apple.Apns.ProviderData.Builder {
      return Apple.Apns.ProviderData.classBuilder() as! Apple.Apns.ProviderData.Builder
    }
    public func getBuilder() -> Apple.Apns.ProviderData.Builder {
      return classBuilder() as! Apple.Apns.ProviderData.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.ProviderData.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.ProviderData.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.ProviderData.Builder {
      return try Apple.Apns.ProviderData.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.ProviderData) throws -> Apple.Apns.ProviderData.Builder {
      return try Apple.Apns.ProviderData.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasBundle {
        jsonMap["bundle"] = bundle
      }
      if hasToken {
        jsonMap["token"] = token
      }
      if hasPriority {
        jsonMap["priority"] = UInt(priority)
      }
      if hasPayload {
        jsonMap["payload"] = try payload.encode()
      }
      if hasServiceIdentity {
        jsonMap["serviceIdentity"] = serviceIdentity.toString()
      }
      if hasCertificatePath {
        jsonMap["certificatePath"] = certificatePath
      }
      if hasCertificatePassphrase {
        jsonMap["certificatePassphrase"] = certificatePassphrase
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasBundle {
        output += "\(indent) bundle: \(bundle) \n"
      }
      if hasToken {
        output += "\(indent) token: \(token) \n"
      }
      if hasPriority {
        output += "\(indent) priority: \(priority) \n"
      }
      if hasPayload {
        output += "\(indent) payload {\n"
        if let outDescPayload = payload {
          output += try outDescPayload.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasServiceIdentity) {
        output += "\(indent) serviceIdentity: \(serviceIdentity.description)\n"
      }
      if hasCertificatePath {
        output += "\(indent) certificatePath: \(certificatePath) \n"
      }
      if hasCertificatePassphrase {
        output += "\(indent) certificatePassphrase: \(certificatePassphrase) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasBundle {
               hashCode = (hashCode &* 31) &+ bundle.hashValue
            }
            if hasToken {
               hashCode = (hashCode &* 31) &+ token.hashValue
            }
            if hasPriority {
               hashCode = (hashCode &* 31) &+ priority.hashValue
            }
            if hasPayload {
                if let hashValuepayload = payload?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepayload
                }
            }
            if hasServiceIdentity {
               hashCode = (hashCode &* 31) &+ Int(serviceIdentity.rawValue)
            }
            if hasCertificatePath {
               hashCode = (hashCode &* 31) &+ certificatePath.hashValue
            }
            if hasCertificatePassphrase {
               hashCode = (hashCode &* 31) &+ certificatePassphrase.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.ProviderData"
    }
    override public func className() -> String {
        return "Apple.Apns.ProviderData"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Apple.Apns.ProviderData = Apple.Apns.ProviderData()
      public func getMessage() -> Apple.Apns.ProviderData {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasBundle:Bool {
           get {
                return builderResult.hasBundle
           }
      }
      public var bundle:String {
           get {
                return builderResult.bundle
           }
           set (value) {
               builderResult.hasBundle = true
               builderResult.bundle = value
           }
      }
      @discardableResult
      public func setBundle(_ value:String) -> Apple.Apns.ProviderData.Builder {
        self.bundle = value
        return self
      }
      @discardableResult
      public func clearBundle() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasBundle = false
           builderResult.bundle = ""
           return self
      }
      public var hasToken:Bool {
           get {
                return builderResult.hasToken
           }
      }
      public var token:String {
           get {
                return builderResult.token
           }
           set (value) {
               builderResult.hasToken = true
               builderResult.token = value
           }
      }
      @discardableResult
      public func setToken(_ value:String) -> Apple.Apns.ProviderData.Builder {
        self.token = value
        return self
      }
      @discardableResult
      public func clearToken() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasToken = false
           builderResult.token = ""
           return self
      }
      public var hasPriority:Bool {
           get {
                return builderResult.hasPriority
           }
      }
      public var priority:UInt32 {
           get {
                return builderResult.priority
           }
           set (value) {
               builderResult.hasPriority = true
               builderResult.priority = value
           }
      }
      @discardableResult
      public func setPriority(_ value:UInt32) -> Apple.Apns.ProviderData.Builder {
        self.priority = value
        return self
      }
      @discardableResult
      public func clearPriority() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasPriority = false
           builderResult.priority = UInt32(0)
           return self
      }
      public var hasPayload:Bool {
           get {
               return builderResult.hasPayload
           }
      }
      public var payload:Apple.Apns.Push! {
           get {
               if payloadBuilder_ != nil {
                  builderResult.payload = payloadBuilder_.getMessage()
               }
               return builderResult.payload
           }
           set (value) {
               builderResult.hasPayload = true
               builderResult.payload = value
           }
      }
      fileprivate var payloadBuilder_:Apple.Apns.Push.Builder! {
           didSet {
              builderResult.hasPayload = true
           }
      }
      public func getPayloadBuilder() -> Apple.Apns.Push.Builder {
        if payloadBuilder_ == nil {
           payloadBuilder_ = Apple.Apns.Push.Builder()
           builderResult.payload = payloadBuilder_.getMessage()
           if payload != nil {
              try! payloadBuilder_.mergeFrom(other: payload)
           }
        }
        return payloadBuilder_
      }
      @discardableResult
      public func setPayload(_ value:Apple.Apns.Push!) -> Apple.Apns.ProviderData.Builder {
        self.payload = value
        return self
      }
      @discardableResult
      public func mergePayload(value:Apple.Apns.Push) throws -> Apple.Apns.ProviderData.Builder {
        if builderResult.hasPayload {
          builderResult.payload = try Apple.Apns.Push.builderWithPrototype(prototype:builderResult.payload).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.payload = value
        }
        builderResult.hasPayload = true
        return self
      }
      @discardableResult
      public func clearPayload() -> Apple.Apns.ProviderData.Builder {
        payloadBuilder_ = nil
        builderResult.hasPayload = false
        builderResult.payload = nil
        return self
      }
        public var hasServiceIdentity:Bool{
            get {
                return builderResult.hasServiceIdentity
            }
        }
        public var serviceIdentity:Apple.Apns.ProviderData.Identity {
            get {
                return builderResult.serviceIdentity
            }
            set (value) {
                builderResult.hasServiceIdentity = true
                builderResult.serviceIdentity = value
            }
        }
      @discardableResult
        public func setServiceIdentity(_ value:Apple.Apns.ProviderData.Identity) -> Apple.Apns.ProviderData.Builder {
          self.serviceIdentity = value
          return self
        }
      @discardableResult
        public func clearServiceIdentity() -> Apple.Apns.ProviderData.Builder {
           builderResult.hasServiceIdentity = false
           builderResult.serviceIdentity = .production
           return self
        }
      public var hasCertificatePath:Bool {
           get {
                return builderResult.hasCertificatePath
           }
      }
      public var certificatePath:String {
           get {
                return builderResult.certificatePath
           }
           set (value) {
               builderResult.hasCertificatePath = true
               builderResult.certificatePath = value
           }
      }
      @discardableResult
      public func setCertificatePath(_ value:String) -> Apple.Apns.ProviderData.Builder {
        self.certificatePath = value
        return self
      }
      @discardableResult
      public func clearCertificatePath() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasCertificatePath = false
           builderResult.certificatePath = ""
           return self
      }
      public var hasCertificatePassphrase:Bool {
           get {
                return builderResult.hasCertificatePassphrase
           }
      }
      public var certificatePassphrase:String {
           get {
                return builderResult.certificatePassphrase
           }
           set (value) {
               builderResult.hasCertificatePassphrase = true
               builderResult.certificatePassphrase = value
           }
      }
      @discardableResult
      public func setCertificatePassphrase(_ value:String) -> Apple.Apns.ProviderData.Builder {
        self.certificatePassphrase = value
        return self
      }
      @discardableResult
      public func clearCertificatePassphrase() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasCertificatePassphrase = false
           builderResult.certificatePassphrase = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Apple.Apns.ProviderData.Builder {
        builderResult = Apple.Apns.ProviderData()
        return self
      }
      override public func clone() throws -> Apple.Apns.ProviderData.Builder {
        return try Apple.Apns.ProviderData.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Apple.Apns.ProviderData {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.ProviderData {
        let returnMe:Apple.Apns.ProviderData = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Apple.Apns.ProviderData) throws -> Apple.Apns.ProviderData.Builder {
        if other == Apple.Apns.ProviderData() {
         return self
        }
        if other.hasBundle {
             bundle = other.bundle
        }
        if other.hasToken {
             token = other.token
        }
        if other.hasPriority {
             priority = other.priority
        }
        if (other.hasPayload) {
            try mergePayload(value: other.payload)
        }
        if other.hasServiceIdentity {
             serviceIdentity = other.serviceIdentity
        }
        if other.hasCertificatePath {
             certificatePath = other.certificatePath
        }
        if other.hasCertificatePassphrase {
             certificatePassphrase = other.certificatePassphrase
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.ProviderData.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            bundle = try codedInputStream.readString()

          case 18:
            token = try codedInputStream.readString()

          case 24:
            priority = try codedInputStream.readUInt32()

          case 34:
            let subBuilder:Apple.Apns.Push.Builder = Apple.Apns.Push.Builder()
            if hasPayload {
              try subBuilder.mergeFrom(other: payload)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            payload = subBuilder.buildPartial()

          case 40:
            let valueIntserviceIdentity = try codedInputStream.readEnum()
            if let enumsserviceIdentity = Apple.Apns.ProviderData.Identity(rawValue:valueIntserviceIdentity){
                 serviceIdentity = enumsserviceIdentity
            } else {
                 try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntserviceIdentity))
            }

          case 50:
            certificatePath = try codedInputStream.readString()

          case 58:
            certificatePassphrase = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.ProviderData.Builder {
        let resultDecodedBuilder = Apple.Apns.ProviderData.Builder()
        if let jsonValueBundle = jsonMap["bundle"] as? String {
          resultDecodedBuilder.bundle = jsonValueBundle
        }
        if let jsonValueToken = jsonMap["token"] as? String {
          resultDecodedBuilder.token = jsonValueToken
        }
        if let jsonValuePriority = jsonMap["priority"] as? UInt {
          resultDecodedBuilder.priority = UInt32(jsonValuePriority)
        }
        if let jsonValuePayload = jsonMap["payload"] as? Dictionary<String,Any> {
          resultDecodedBuilder.payload = try Apple.Apns.Push.Builder.decodeToBuilder(jsonMap:jsonValuePayload).build()

        }
        if let jsonValueServiceIdentity = jsonMap["serviceIdentity"] as? String {
          resultDecodedBuilder.serviceIdentity = try Apple.Apns.ProviderData.Identity.fromString(str: jsonValueServiceIdentity)
        }
        if let jsonValueCertificatePath = jsonMap["certificatePath"] as? String {
          resultDecodedBuilder.certificatePath = jsonValueCertificatePath
        }
        if let jsonValueCertificatePassphrase = jsonMap["certificatePassphrase"] as? String {
          resultDecodedBuilder.certificatePassphrase = jsonValueCertificatePassphrase
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Apple.Apns.ProviderData.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.ProviderData.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class Response : GeneratedMessage {

    public static func == (lhs: Apple.Apns.Response, rhs: Apple.Apns.Response) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasStatusCode == rhs.hasStatusCode) && (!lhs.hasStatusCode || lhs.statusCode == rhs.statusCode)
      fieldCheck = fieldCheck && (lhs.hasApnsId == rhs.hasApnsId) && (!lhs.hasApnsId || lhs.apnsId == rhs.apnsId)
      fieldCheck = fieldCheck && (lhs.hasReason == rhs.hasReason) && (!lhs.hasReason || lhs.reason == rhs.reason)
      fieldCheck = fieldCheck && (lhs.hasReasonDescription == rhs.hasReasonDescription) && (!lhs.hasReasonDescription || lhs.reasonDescription == rhs.reasonDescription)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    //200 - Success
    //400 - Bad request
    //403 - There was an error with the certificate.
    //405 - The request used a bad :method value. Only POST requests are supported.
    //410 - The device token is no longer active for the topic.
    //413 - The notification payload was too large.
    //429 - The server received too many requests for the same device token. 
    //500 - Internal server error
    //503 - The server is shutting down and unavailable.
    public fileprivate(set) var statusCode:Int32 = Int32(0)
    public fileprivate(set) var hasStatusCode:Bool = false

    public fileprivate(set) var apnsId:String = ""
    public fileprivate(set) var hasApnsId:Bool = false

    public fileprivate(set) var reason:String = ""
    public fileprivate(set) var hasReason:Bool = false

    public fileprivate(set) var reasonDescription:String = ""
    public fileprivate(set) var hasReasonDescription:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasStatusCode {
        try codedOutputStream.writeInt32(fieldNumber: 1, value:statusCode)
      }
      if hasApnsId {
        try codedOutputStream.writeString(fieldNumber: 2, value:apnsId)
      }
      if hasReason {
        try codedOutputStream.writeString(fieldNumber: 3, value:reason)
      }
      if hasReasonDescription {
        try codedOutputStream.writeString(fieldNumber: 4, value:reasonDescription)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasStatusCode {
        serialize_size += statusCode.computeInt32Size(fieldNumber: 1)
      }
      if hasApnsId {
        serialize_size += apnsId.computeStringSize(fieldNumber: 2)
      }
      if hasReason {
        serialize_size += reason.computeStringSize(fieldNumber: 3)
      }
      if hasReasonDescription {
        serialize_size += reasonDescription.computeStringSize(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Apple.Apns.Response.Builder {
      return Apple.Apns.Response.classBuilder() as! Apple.Apns.Response.Builder
    }
    public func getBuilder() -> Apple.Apns.Response.Builder {
      return classBuilder() as! Apple.Apns.Response.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.Response.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.Response.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.Response.Builder {
      return try Apple.Apns.Response.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.Response) throws -> Apple.Apns.Response.Builder {
      return try Apple.Apns.Response.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasStatusCode {
        jsonMap["statusCode"] = Int(statusCode)
      }
      if hasApnsId {
        jsonMap["apnsId"] = apnsId
      }
      if hasReason {
        jsonMap["reason"] = reason
      }
      if hasReasonDescription {
        jsonMap["reasonDescription"] = reasonDescription
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasStatusCode {
        output += "\(indent) statusCode: \(statusCode) \n"
      }
      if hasApnsId {
        output += "\(indent) apnsId: \(apnsId) \n"
      }
      if hasReason {
        output += "\(indent) reason: \(reason) \n"
      }
      if hasReasonDescription {
        output += "\(indent) reasonDescription: \(reasonDescription) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatusCode {
               hashCode = (hashCode &* 31) &+ statusCode.hashValue
            }
            if hasApnsId {
               hashCode = (hashCode &* 31) &+ apnsId.hashValue
            }
            if hasReason {
               hashCode = (hashCode &* 31) &+ reason.hashValue
            }
            if hasReasonDescription {
               hashCode = (hashCode &* 31) &+ reasonDescription.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.Response"
    }
    override public func className() -> String {
        return "Apple.Apns.Response"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Apple.Apns.Response = Apple.Apns.Response()
      public func getMessage() -> Apple.Apns.Response {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasStatusCode:Bool {
           get {
                return builderResult.hasStatusCode
           }
      }
      public var statusCode:Int32 {
           get {
                return builderResult.statusCode
           }
           set (value) {
               builderResult.hasStatusCode = true
               builderResult.statusCode = value
           }
      }
      @discardableResult
      public func setStatusCode(_ value:Int32) -> Apple.Apns.Response.Builder {
        self.statusCode = value
        return self
      }
      @discardableResult
      public func clearStatusCode() -> Apple.Apns.Response.Builder{
           builderResult.hasStatusCode = false
           builderResult.statusCode = Int32(0)
           return self
      }
      public var hasApnsId:Bool {
           get {
                return builderResult.hasApnsId
           }
      }
      public var apnsId:String {
           get {
                return builderResult.apnsId
           }
           set (value) {
               builderResult.hasApnsId = true
               builderResult.apnsId = value
           }
      }
      @discardableResult
      public func setApnsId(_ value:String) -> Apple.Apns.Response.Builder {
        self.apnsId = value
        return self
      }
      @discardableResult
      public func clearApnsId() -> Apple.Apns.Response.Builder{
           builderResult.hasApnsId = false
           builderResult.apnsId = ""
           return self
      }
      public var hasReason:Bool {
           get {
                return builderResult.hasReason
           }
      }
      public var reason:String {
           get {
                return builderResult.reason
           }
           set (value) {
               builderResult.hasReason = true
               builderResult.reason = value
           }
      }
      @discardableResult
      public func setReason(_ value:String) -> Apple.Apns.Response.Builder {
        self.reason = value
        return self
      }
      @discardableResult
      public func clearReason() -> Apple.Apns.Response.Builder{
           builderResult.hasReason = false
           builderResult.reason = ""
           return self
      }
      public var hasReasonDescription:Bool {
           get {
                return builderResult.hasReasonDescription
           }
      }
      public var reasonDescription:String {
           get {
                return builderResult.reasonDescription
           }
           set (value) {
               builderResult.hasReasonDescription = true
               builderResult.reasonDescription = value
           }
      }
      @discardableResult
      public func setReasonDescription(_ value:String) -> Apple.Apns.Response.Builder {
        self.reasonDescription = value
        return self
      }
      @discardableResult
      public func clearReasonDescription() -> Apple.Apns.Response.Builder{
           builderResult.hasReasonDescription = false
           builderResult.reasonDescription = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Apple.Apns.Response.Builder {
        builderResult = Apple.Apns.Response()
        return self
      }
      override public func clone() throws -> Apple.Apns.Response.Builder {
        return try Apple.Apns.Response.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Apple.Apns.Response {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.Response {
        let returnMe:Apple.Apns.Response = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Apple.Apns.Response) throws -> Apple.Apns.Response.Builder {
        if other == Apple.Apns.Response() {
         return self
        }
        if other.hasStatusCode {
             statusCode = other.statusCode
        }
        if other.hasApnsId {
             apnsId = other.apnsId
        }
        if other.hasReason {
             reason = other.reason
        }
        if other.hasReasonDescription {
             reasonDescription = other.reasonDescription
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Response.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            statusCode = try codedInputStream.readInt32()

          case 18:
            apnsId = try codedInputStream.readString()

          case 26:
            reason = try codedInputStream.readString()

          case 34:
            reasonDescription = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Response.Builder {
        let resultDecodedBuilder = Apple.Apns.Response.Builder()
        if let jsonValueStatusCode = jsonMap["statusCode"] as? Int {
          resultDecodedBuilder.statusCode = Int32(jsonValueStatusCode)
        }
        if let jsonValueApnsId = jsonMap["apnsId"] as? String {
          resultDecodedBuilder.apnsId = jsonValueApnsId
        }
        if let jsonValueReason = jsonMap["reason"] as? String {
          resultDecodedBuilder.reason = jsonValueReason
        }
        if let jsonValueReasonDescription = jsonMap["reasonDescription"] as? String {
          resultDecodedBuilder.reasonDescription = jsonValueReasonDescription
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Apple.Apns.Response.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.Response.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class Push : GeneratedMessage {

    public static func == (lhs: Apple.Apns.Push, rhs: Apple.Apns.Push) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasAps == rhs.hasAps) && (!lhs.hasAps || lhs.aps == rhs.aps)
      fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
      fieldCheck = fieldCheck && (lhs.hasVideo == rhs.hasVideo) && (!lhs.hasVideo || lhs.video == rhs.video)
      fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class Aps : GeneratedMessage {

        public static func == (lhs: Apple.Apns.Push.Aps, rhs: Apple.Apns.Push.Aps) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasAlert == rhs.hasAlert) && (!lhs.hasAlert || lhs.alert == rhs.alert)
          fieldCheck = fieldCheck && (lhs.hasSound == rhs.hasSound) && (!lhs.hasSound || lhs.sound == rhs.sound)
          fieldCheck = fieldCheck && (lhs.hasBadge == rhs.hasBadge) && (!lhs.hasBadge || lhs.badge == rhs.badge)
          fieldCheck = fieldCheck && (lhs.hasContentAvailable == rhs.hasContentAvailable) && (!lhs.hasContentAvailable || lhs.contentAvailable == rhs.contentAvailable)
          fieldCheck = fieldCheck && (lhs.hasMutableContent == rhs.hasMutableContent) && (!lhs.hasMutableContent || lhs.mutableContent == rhs.mutableContent)
          fieldCheck = fieldCheck && (lhs.hasCategory == rhs.hasCategory) && (!lhs.hasCategory || lhs.category == rhs.category)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var alert:String = ""
        public fileprivate(set) var hasAlert:Bool = false

        public fileprivate(set) var sound:String = ""
        public fileprivate(set) var hasSound:Bool = false

        public fileprivate(set) var badge:Int32 = Int32(0)
        public fileprivate(set) var hasBadge:Bool = false

        public fileprivate(set) var contentAvailable:Int32 = Int32(0)
        public fileprivate(set) var hasContentAvailable:Bool = false

        public fileprivate(set) var mutableContent:Int32 = Int32(0)
        public fileprivate(set) var hasMutableContent:Bool = false

        public fileprivate(set) var category:String = ""
        public fileprivate(set) var hasCategory:Bool = false

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasAlert {
            try codedOutputStream.writeString(fieldNumber: 1, value:alert)
          }
          if hasSound {
            try codedOutputStream.writeString(fieldNumber: 2, value:sound)
          }
          if hasBadge {
            try codedOutputStream.writeInt32(fieldNumber: 3, value:badge)
          }
          if hasContentAvailable {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:contentAvailable)
          }
          if hasMutableContent {
            try codedOutputStream.writeInt32(fieldNumber: 5, value:mutableContent)
          }
          if hasCategory {
            try codedOutputStream.writeString(fieldNumber: 6, value:category)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasAlert {
            serialize_size += alert.computeStringSize(fieldNumber: 1)
          }
          if hasSound {
            serialize_size += sound.computeStringSize(fieldNumber: 2)
          }
          if hasBadge {
            serialize_size += badge.computeInt32Size(fieldNumber: 3)
          }
          if hasContentAvailable {
            serialize_size += contentAvailable.computeInt32Size(fieldNumber: 4)
          }
          if hasMutableContent {
            serialize_size += mutableContent.computeInt32Size(fieldNumber: 5)
          }
          if hasCategory {
            serialize_size += category.computeStringSize(fieldNumber: 6)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Apple.Apns.Push.Aps.Builder {
          return Apple.Apns.Push.Aps.classBuilder() as! Apple.Apns.Push.Aps.Builder
        }
        public func getBuilder() -> Apple.Apns.Push.Aps.Builder {
          return classBuilder() as! Apple.Apns.Push.Aps.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Apple.Apns.Push.Aps.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Apple.Apns.Push.Aps.Builder()
        }
        public func toBuilder() throws -> Apple.Apns.Push.Aps.Builder {
          return try Apple.Apns.Push.Aps.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Aps.Builder {
          return try Apple.Apns.Push.Aps.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasAlert {
            jsonMap["alert"] = alert
          }
          if hasSound {
            jsonMap["sound"] = sound
          }
          if hasBadge {
            jsonMap["badge"] = Int(badge)
          }
          if hasContentAvailable {
            jsonMap["contentAvailable"] = Int(contentAvailable)
          }
          if hasMutableContent {
            jsonMap["mutableContent"] = Int(mutableContent)
          }
          if hasCategory {
            jsonMap["category"] = category
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasAlert {
            output += "\(indent) alert: \(alert) \n"
          }
          if hasSound {
            output += "\(indent) sound: \(sound) \n"
          }
          if hasBadge {
            output += "\(indent) badge: \(badge) \n"
          }
          if hasContentAvailable {
            output += "\(indent) contentAvailable: \(contentAvailable) \n"
          }
          if hasMutableContent {
            output += "\(indent) mutableContent: \(mutableContent) \n"
          }
          if hasCategory {
            output += "\(indent) category: \(category) \n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAlert {
                   hashCode = (hashCode &* 31) &+ alert.hashValue
                }
                if hasSound {
                   hashCode = (hashCode &* 31) &+ sound.hashValue
                }
                if hasBadge {
                   hashCode = (hashCode &* 31) &+ badge.hashValue
                }
                if hasContentAvailable {
                   hashCode = (hashCode &* 31) &+ contentAvailable.hashValue
                }
                if hasMutableContent {
                   hashCode = (hashCode &* 31) &+ mutableContent.hashValue
                }
                if hasCategory {
                   hashCode = (hashCode &* 31) &+ category.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apple.Apns.Push.Aps"
        }
        override public func className() -> String {
            return "Apple.Apns.Push.Aps"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Apple.Apns.Push.Aps = Apple.Apns.Push.Aps()
          public func getMessage() -> Apple.Apns.Push.Aps {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasAlert:Bool {
               get {
                    return builderResult.hasAlert
               }
          }
          public var alert:String {
               get {
                    return builderResult.alert
               }
               set (value) {
                   builderResult.hasAlert = true
                   builderResult.alert = value
               }
          }
          @discardableResult
          public func setAlert(_ value:String) -> Apple.Apns.Push.Aps.Builder {
            self.alert = value
            return self
          }
          @discardableResult
          public func clearAlert() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasAlert = false
               builderResult.alert = ""
               return self
          }
          public var hasSound:Bool {
               get {
                    return builderResult.hasSound
               }
          }
          public var sound:String {
               get {
                    return builderResult.sound
               }
               set (value) {
                   builderResult.hasSound = true
                   builderResult.sound = value
               }
          }
          @discardableResult
          public func setSound(_ value:String) -> Apple.Apns.Push.Aps.Builder {
            self.sound = value
            return self
          }
          @discardableResult
          public func clearSound() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasSound = false
               builderResult.sound = ""
               return self
          }
          public var hasBadge:Bool {
               get {
                    return builderResult.hasBadge
               }
          }
          public var badge:Int32 {
               get {
                    return builderResult.badge
               }
               set (value) {
                   builderResult.hasBadge = true
                   builderResult.badge = value
               }
          }
          @discardableResult
          public func setBadge(_ value:Int32) -> Apple.Apns.Push.Aps.Builder {
            self.badge = value
            return self
          }
          @discardableResult
          public func clearBadge() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasBadge = false
               builderResult.badge = Int32(0)
               return self
          }
          public var hasContentAvailable:Bool {
               get {
                    return builderResult.hasContentAvailable
               }
          }
          public var contentAvailable:Int32 {
               get {
                    return builderResult.contentAvailable
               }
               set (value) {
                   builderResult.hasContentAvailable = true
                   builderResult.contentAvailable = value
               }
          }
          @discardableResult
          public func setContentAvailable(_ value:Int32) -> Apple.Apns.Push.Aps.Builder {
            self.contentAvailable = value
            return self
          }
          @discardableResult
          public func clearContentAvailable() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasContentAvailable = false
               builderResult.contentAvailable = Int32(0)
               return self
          }
          public var hasMutableContent:Bool {
               get {
                    return builderResult.hasMutableContent
               }
          }
          public var mutableContent:Int32 {
               get {
                    return builderResult.mutableContent
               }
               set (value) {
                   builderResult.hasMutableContent = true
                   builderResult.mutableContent = value
               }
          }
          @discardableResult
          public func setMutableContent(_ value:Int32) -> Apple.Apns.Push.Aps.Builder {
            self.mutableContent = value
            return self
          }
          @discardableResult
          public func clearMutableContent() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasMutableContent = false
               builderResult.mutableContent = Int32(0)
               return self
          }
          public var hasCategory:Bool {
               get {
                    return builderResult.hasCategory
               }
          }
          public var category:String {
               get {
                    return builderResult.category
               }
               set (value) {
                   builderResult.hasCategory = true
                   builderResult.category = value
               }
          }
          @discardableResult
          public func setCategory(_ value:String) -> Apple.Apns.Push.Aps.Builder {
            self.category = value
            return self
          }
          @discardableResult
          public func clearCategory() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasCategory = false
               builderResult.category = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Apple.Apns.Push.Aps.Builder {
            builderResult = Apple.Apns.Push.Aps()
            return self
          }
          override public func clone() throws -> Apple.Apns.Push.Aps.Builder {
            return try Apple.Apns.Push.Aps.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Apple.Apns.Push.Aps {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Apple.Apns.Push.Aps {
            let returnMe:Apple.Apns.Push.Aps = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Aps.Builder {
            if other == Apple.Apns.Push.Aps() {
             return self
            }
            if other.hasAlert {
                 alert = other.alert
            }
            if other.hasSound {
                 sound = other.sound
            }
            if other.hasBadge {
                 badge = other.badge
            }
            if other.hasContentAvailable {
                 contentAvailable = other.contentAvailable
            }
            if other.hasMutableContent {
                 mutableContent = other.mutableContent
            }
            if other.hasCategory {
                 category = other.category
            }
            try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Push.Aps.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                alert = try codedInputStream.readString()

              case 18:
                sound = try codedInputStream.readString()

              case 24:
                badge = try codedInputStream.readInt32()

              case 32:
                contentAvailable = try codedInputStream.readInt32()

              case 40:
                mutableContent = try codedInputStream.readInt32()

              case 50:
                category = try codedInputStream.readString()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Push.Aps.Builder {
            let resultDecodedBuilder = Apple.Apns.Push.Aps.Builder()
            if let jsonValueAlert = jsonMap["alert"] as? String {
              resultDecodedBuilder.alert = jsonValueAlert
            }
            if let jsonValueSound = jsonMap["sound"] as? String {
              resultDecodedBuilder.sound = jsonValueSound
            }
            if let jsonValueBadge = jsonMap["badge"] as? Int {
              resultDecodedBuilder.badge = Int32(jsonValueBadge)
            }
            if let jsonValueContentAvailable = jsonMap["contentAvailable"] as? Int {
              resultDecodedBuilder.contentAvailable = Int32(jsonValueContentAvailable)
            }
            if let jsonValueMutableContent = jsonMap["mutableContent"] as? Int {
              resultDecodedBuilder.mutableContent = Int32(jsonValueMutableContent)
            }
            if let jsonValueCategory = jsonMap["category"] as? String {
              resultDecodedBuilder.category = jsonValueCategory
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Apple.Apns.Push.Aps.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var aps:Apple.Apns.Push.Aps!
    public fileprivate(set) var hasAps:Bool = false
    public fileprivate(set) var image:String = ""
    public fileprivate(set) var hasImage:Bool = false

    public fileprivate(set) var video:String = ""
    public fileprivate(set) var hasVideo:Bool = false

    public fileprivate(set) var audio:String = ""
    public fileprivate(set) var hasAudio:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasAps {
        try codedOutputStream.writeMessage(fieldNumber: 1, value:aps)
      }
      if hasImage {
        try codedOutputStream.writeString(fieldNumber: 2, value:image)
      }
      if hasVideo {
        try codedOutputStream.writeString(fieldNumber: 3, value:video)
      }
      if hasAudio {
        try codedOutputStream.writeString(fieldNumber: 4, value:audio)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAps {
          if let varSizeaps = aps?.computeMessageSize(fieldNumber: 1) {
              serialize_size += varSizeaps
          }
      }
      if hasImage {
        serialize_size += image.computeStringSize(fieldNumber: 2)
      }
      if hasVideo {
        serialize_size += video.computeStringSize(fieldNumber: 3)
      }
      if hasAudio {
        serialize_size += audio.computeStringSize(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Apple.Apns.Push.Builder {
      return Apple.Apns.Push.classBuilder() as! Apple.Apns.Push.Builder
    }
    public func getBuilder() -> Apple.Apns.Push.Builder {
      return classBuilder() as! Apple.Apns.Push.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.Push.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Apple.Apns.Push.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.Push.Builder {
      return try Apple.Apns.Push.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.Push) throws -> Apple.Apns.Push.Builder {
      return try Apple.Apns.Push.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasAps {
        jsonMap["aps"] = try aps.encode()
      }
      if hasImage {
        jsonMap["image"] = image
      }
      if hasVideo {
        jsonMap["video"] = video
      }
      if hasAudio {
        jsonMap["audio"] = audio
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasAps {
        output += "\(indent) aps {\n"
        if let outDescAps = aps {
          output += try outDescAps.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasImage {
        output += "\(indent) image: \(image) \n"
      }
      if hasVideo {
        output += "\(indent) video: \(video) \n"
      }
      if hasAudio {
        output += "\(indent) audio: \(audio) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAps {
                if let hashValueaps = aps?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaps
                }
            }
            if hasImage {
               hashCode = (hashCode &* 31) &+ image.hashValue
            }
            if hasVideo {
               hashCode = (hashCode &* 31) &+ video.hashValue
            }
            if hasAudio {
               hashCode = (hashCode &* 31) &+ audio.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.Push"
    }
    override public func className() -> String {
        return "Apple.Apns.Push"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Apple.Apns.Push = Apple.Apns.Push()
      public func getMessage() -> Apple.Apns.Push {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasAps:Bool {
           get {
               return builderResult.hasAps
           }
      }
      public var aps:Apple.Apns.Push.Aps! {
           get {
               if apsBuilder_ != nil {
                  builderResult.aps = apsBuilder_.getMessage()
               }
               return builderResult.aps
           }
           set (value) {
               builderResult.hasAps = true
               builderResult.aps = value
           }
      }
      fileprivate var apsBuilder_:Apple.Apns.Push.Aps.Builder! {
           didSet {
              builderResult.hasAps = true
           }
      }
      public func getApsBuilder() -> Apple.Apns.Push.Aps.Builder {
        if apsBuilder_ == nil {
           apsBuilder_ = Apple.Apns.Push.Aps.Builder()
           builderResult.aps = apsBuilder_.getMessage()
           if aps != nil {
              try! apsBuilder_.mergeFrom(other: aps)
           }
        }
        return apsBuilder_
      }
      @discardableResult
      public func setAps(_ value:Apple.Apns.Push.Aps!) -> Apple.Apns.Push.Builder {
        self.aps = value
        return self
      }
      @discardableResult
      public func mergeAps(value:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Builder {
        if builderResult.hasAps {
          builderResult.aps = try Apple.Apns.Push.Aps.builderWithPrototype(prototype:builderResult.aps).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.aps = value
        }
        builderResult.hasAps = true
        return self
      }
      @discardableResult
      public func clearAps() -> Apple.Apns.Push.Builder {
        apsBuilder_ = nil
        builderResult.hasAps = false
        builderResult.aps = nil
        return self
      }
      public var hasImage:Bool {
           get {
                return builderResult.hasImage
           }
      }
      public var image:String {
           get {
                return builderResult.image
           }
           set (value) {
               builderResult.hasImage = true
               builderResult.image = value
           }
      }
      @discardableResult
      public func setImage(_ value:String) -> Apple.Apns.Push.Builder {
        self.image = value
        return self
      }
      @discardableResult
      public func clearImage() -> Apple.Apns.Push.Builder{
           builderResult.hasImage = false
           builderResult.image = ""
           return self
      }
      public var hasVideo:Bool {
           get {
                return builderResult.hasVideo
           }
      }
      public var video:String {
           get {
                return builderResult.video
           }
           set (value) {
               builderResult.hasVideo = true
               builderResult.video = value
           }
      }
      @discardableResult
      public func setVideo(_ value:String) -> Apple.Apns.Push.Builder {
        self.video = value
        return self
      }
      @discardableResult
      public func clearVideo() -> Apple.Apns.Push.Builder{
           builderResult.hasVideo = false
           builderResult.video = ""
           return self
      }
      public var hasAudio:Bool {
           get {
                return builderResult.hasAudio
           }
      }
      public var audio:String {
           get {
                return builderResult.audio
           }
           set (value) {
               builderResult.hasAudio = true
               builderResult.audio = value
           }
      }
      @discardableResult
      public func setAudio(_ value:String) -> Apple.Apns.Push.Builder {
        self.audio = value
        return self
      }
      @discardableResult
      public func clearAudio() -> Apple.Apns.Push.Builder{
           builderResult.hasAudio = false
           builderResult.audio = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Apple.Apns.Push.Builder {
        builderResult = Apple.Apns.Push()
        return self
      }
      override public func clone() throws -> Apple.Apns.Push.Builder {
        return try Apple.Apns.Push.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Apple.Apns.Push {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.Push {
        let returnMe:Apple.Apns.Push = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Apple.Apns.Push) throws -> Apple.Apns.Push.Builder {
        if other == Apple.Apns.Push() {
         return self
        }
        if (other.hasAps) {
            try mergeAps(value: other.aps)
        }
        if other.hasImage {
             image = other.image
        }
        if other.hasVideo {
             video = other.video
        }
        if other.hasAudio {
             audio = other.audio
        }
        try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Push.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Apple.Apns.Push.Aps.Builder = Apple.Apns.Push.Aps.Builder()
            if hasAps {
              try subBuilder.mergeFrom(other: aps)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            aps = subBuilder.buildPartial()

          case 18:
            image = try codedInputStream.readString()

          case 26:
            video = try codedInputStream.readString()

          case 34:
            audio = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Apple.Apns.Push.Builder {
        let resultDecodedBuilder = Apple.Apns.Push.Builder()
        if let jsonValueAps = jsonMap["aps"] as? Dictionary<String,Any> {
          resultDecodedBuilder.aps = try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsonMap:jsonValueAps).build()

        }
        if let jsonValueImage = jsonMap["image"] as? String {
          resultDecodedBuilder.image = jsonValueImage
        }
        if let jsonValueVideo = jsonMap["video"] as? String {
          resultDecodedBuilder.video = jsonValueVideo
        }
        if let jsonValueAudio = jsonMap["audio"] as? String {
          resultDecodedBuilder.audio = jsonValueAudio
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Apple.Apns.Push.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.Push.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Apple.Apns.ProviderData: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apple.Apns.ProviderData> {
    var mergedArray = Array<Apple.Apns.ProviderData>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apple.Apns.ProviderData? {
    return try Apple.Apns.ProviderData.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(data: data, extensionRegistry:Apple.Apns.PushServiceRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
    return try Apple.Apns.ProviderData.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Apple.Apns.Response: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apple.Apns.Response> {
    var mergedArray = Array<Apple.Apns.Response>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apple.Apns.Response? {
    return try Apple.Apns.Response.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(data: data, extensionRegistry:Apple.Apns.PushServiceRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
    return try Apple.Apns.Response.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Apple.Apns.Push: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apple.Apns.Push> {
    var mergedArray = Array<Apple.Apns.Push>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apple.Apns.Push? {
    return try Apple.Apns.Push.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(data: data, extensionRegistry:Apple.Apns.PushServiceRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
    return try Apple.Apns.Push.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Apple.Apns.Push.Aps: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Apple.Apns.Push.Aps> {
    var mergedArray = Array<Apple.Apns.Push.Aps>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Apple.Apns.Push.Aps? {
    return try Apple.Apns.Push.Aps.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(data: data, extensionRegistry:Apple.Apns.PushServiceRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
    return try Apple.Apns.Push.Aps.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
