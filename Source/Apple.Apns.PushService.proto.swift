// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "PushService.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Apple { public struct Apns { }}

public func == (lhs: Apple.Apns.ProviderData, rhs: Apple.Apns.ProviderData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasBundle == rhs.hasBundle) && (!lhs.hasBundle || lhs.bundle == rhs.bundle)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = fieldCheck && (lhs.hasPriority == rhs.hasPriority) && (!lhs.hasPriority || lhs.priority == rhs.priority)
  fieldCheck = fieldCheck && (lhs.hasPayload == rhs.hasPayload) && (!lhs.hasPayload || lhs.payload == rhs.payload)
  fieldCheck = fieldCheck && (lhs.hasServiceIdentity == rhs.hasServiceIdentity) && (!lhs.hasServiceIdentity || lhs.serviceIdentity == rhs.serviceIdentity)
  fieldCheck = fieldCheck && (lhs.hasCertificateName == rhs.hasCertificateName) && (!lhs.hasCertificateName || lhs.certificateName == rhs.certificateName)
  fieldCheck = fieldCheck && (lhs.hasCertificatePassphrase == rhs.hasCertificatePassphrase) && (!lhs.hasCertificatePassphrase || lhs.certificatePassphrase == rhs.certificatePassphrase)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Apple.Apns.Response, rhs: Apple.Apns.Response) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatusCode == rhs.hasStatusCode) && (!lhs.hasStatusCode || lhs.statusCode == rhs.statusCode)
  fieldCheck = fieldCheck && (lhs.hasApnsId == rhs.hasApnsId) && (!lhs.hasApnsId || lhs.apnsId == rhs.apnsId)
  fieldCheck = fieldCheck && (lhs.hasReason == rhs.hasReason) && (!lhs.hasReason || lhs.reason == rhs.reason)
  fieldCheck = fieldCheck && (lhs.hasReasonDescription == rhs.hasReasonDescription) && (!lhs.hasReasonDescription || lhs.reasonDescription == rhs.reasonDescription)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Apple.Apns.Push, rhs: Apple.Apns.Push) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAps == rhs.hasAps) && (!lhs.hasAps || lhs.aps == rhs.aps)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Apple.Apns.Push.Aps, rhs: Apple.Apns.Push.Aps) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasAlert == rhs.hasAlert) && (!lhs.hasAlert || lhs.alert == rhs.alert)
  fieldCheck = fieldCheck && (lhs.hasSound == rhs.hasSound) && (!lhs.hasSound || lhs.sound == rhs.sound)
  fieldCheck = fieldCheck && (lhs.hasBadge == rhs.hasBadge) && (!lhs.hasBadge || lhs.badge == rhs.badge)
  fieldCheck = fieldCheck && (lhs.hasContentAvailable == rhs.hasContentAvailable) && (!lhs.hasContentAvailable || lhs.contentAvailable == rhs.contentAvailable)
  fieldCheck = fieldCheck && (lhs.hasCategory == rhs.hasCategory) && (!lhs.hasCategory || lhs.category == rhs.category)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Apple.Apns {
  public struct PushServiceRoot {
    public static var sharedInstance : PushServiceRoot {
     struct Static {
         static let instance : PushServiceRoot = PushServiceRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class ProviderData : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Identity:Int32 {
        case Production = 0
        case Development = 1
        public func toString() -> String {
          switch self {
          case .Production: return "Production"
          case .Development: return "Development"
          }
        }
        public static func fromString(str:String) throws -> Apple.Apns.ProviderData.Identity {
          switch str {
          case "Production":  return .Production
          case "Development":  return .Development
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
      }

      //Enum type declaration end 

    public private(set) var hasBundle:Bool = false
    public private(set) var bundle:String = ""

    public private(set) var hasToken:Bool = false
    public private(set) var token:String = ""

    public private(set) var hasPriority:Bool = false
    public private(set) var priority:UInt32 = UInt32(0)

    public private(set) var hasPayload:Bool = false
    public private(set) var payload:Apple.Apns.Push!
    public private(set) var serviceIdentity:Apple.Apns.ProviderData.Identity = Apple.Apns.ProviderData.Identity.Production
    public private(set) var hasServiceIdentity:Bool = false
    public private(set) var hasCertificateName:Bool = false
    public private(set) var certificateName:String = ""

    public private(set) var hasCertificatePassphrase:Bool = false
    public private(set) var certificatePassphrase:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasBundle {
        try output.writeString(1, value:bundle)
      }
      if hasToken {
        try output.writeString(2, value:token)
      }
      if hasPriority {
        try output.writeUInt32(3, value:priority)
      }
      if hasPayload {
        try output.writeMessage(4, value:payload)
      }
      if hasServiceIdentity {
        try output.writeEnum(5, value:serviceIdentity.rawValue)
      }
      if hasCertificateName {
        try output.writeString(6, value:certificateName)
      }
      if hasCertificatePassphrase {
        try output.writeString(7, value:certificatePassphrase)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasBundle {
        serialize_size += bundle.computeStringSize(1)
      }
      if hasToken {
        serialize_size += token.computeStringSize(2)
      }
      if hasPriority {
        serialize_size += priority.computeUInt32Size(3)
      }
      if hasPayload {
          if let varSizepayload = payload?.computeMessageSize(4) {
              serialize_size += varSizepayload
          }
      }
      if (hasServiceIdentity) {
        serialize_size += serviceIdentity.rawValue.computeEnumSize(5)
      }
      if hasCertificateName {
        serialize_size += certificateName.computeStringSize(6)
      }
      if hasCertificatePassphrase {
        serialize_size += certificatePassphrase.computeStringSize(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Apple.Apns.ProviderData> {
      var mergedArray = Array<Apple.Apns.ProviderData>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Apple.Apns.ProviderData? {
      return try Apple.Apns.ProviderData.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromData(data, extensionRegistry:Apple.Apns.PushServiceRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Apple.Apns.ProviderData.Builder {
      return Apple.Apns.ProviderData.classBuilder() as! Apple.Apns.ProviderData.Builder
    }
    public func getBuilder() -> Apple.Apns.ProviderData.Builder {
      return classBuilder() as! Apple.Apns.ProviderData.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Apple.Apns.ProviderData.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Apple.Apns.ProviderData.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.ProviderData.Builder {
      return try Apple.Apns.ProviderData.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.ProviderData) throws -> Apple.Apns.ProviderData.Builder {
      return try Apple.Apns.ProviderData.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasBundle {
        jsonMap["bundle"] = bundle
      }
      if hasToken {
        jsonMap["token"] = token
      }
      if hasPriority {
        jsonMap["priority"] = NSNumber(unsignedInt:priority)
      }
      if hasPayload {
        jsonMap["payload"] = try payload.encode()
      }
      if hasServiceIdentity {
        jsonMap["serviceIdentity"] = serviceIdentity.toString()
      }
      if hasCertificateName {
        jsonMap["certificateName"] = certificateName
      }
      if hasCertificatePassphrase {
        jsonMap["certificatePassphrase"] = certificatePassphrase
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Apple.Apns.ProviderData {
      return try Apple.Apns.ProviderData.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasBundle {
        output += "\(indent) bundle: \(bundle) \n"
      }
      if hasToken {
        output += "\(indent) token: \(token) \n"
      }
      if hasPriority {
        output += "\(indent) priority: \(priority) \n"
      }
      if hasPayload {
        output += "\(indent) payload {\n"
        if let outDescPayload = payload {
          output += try outDescPayload.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasServiceIdentity) {
        output += "\(indent) serviceIdentity: \(serviceIdentity.rawValue)\n"
      }
      if hasCertificateName {
        output += "\(indent) certificateName: \(certificateName) \n"
      }
      if hasCertificatePassphrase {
        output += "\(indent) certificatePassphrase: \(certificatePassphrase) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasBundle {
               hashCode = (hashCode &* 31) &+ bundle.hashValue
            }
            if hasToken {
               hashCode = (hashCode &* 31) &+ token.hashValue
            }
            if hasPriority {
               hashCode = (hashCode &* 31) &+ priority.hashValue
            }
            if hasPayload {
                if let hashValuepayload = payload?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepayload
                }
            }
            if hasServiceIdentity {
               hashCode = (hashCode &* 31) &+ Int(serviceIdentity.rawValue)
            }
            if hasCertificateName {
               hashCode = (hashCode &* 31) &+ certificateName.hashValue
            }
            if hasCertificatePassphrase {
               hashCode = (hashCode &* 31) &+ certificatePassphrase.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.ProviderData"
    }
    override public func className() -> String {
        return "Apple.Apns.ProviderData"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Apple.Apns.ProviderData.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Apple.Apns.ProviderData = Apple.Apns.ProviderData()
      public func getMessage() -> Apple.Apns.ProviderData {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasBundle:Bool {
           get {
                return builderResult.hasBundle
           }
      }
      public var bundle:String {
           get {
                return builderResult.bundle
           }
           set (value) {
               builderResult.hasBundle = true
               builderResult.bundle = value
           }
      }
      public func setBundle(value:String) -> Apple.Apns.ProviderData.Builder {
        self.bundle = value
        return self
      }
      public func clearBundle() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasBundle = false
           builderResult.bundle = ""
           return self
      }
      public var hasToken:Bool {
           get {
                return builderResult.hasToken
           }
      }
      public var token:String {
           get {
                return builderResult.token
           }
           set (value) {
               builderResult.hasToken = true
               builderResult.token = value
           }
      }
      public func setToken(value:String) -> Apple.Apns.ProviderData.Builder {
        self.token = value
        return self
      }
      public func clearToken() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasToken = false
           builderResult.token = ""
           return self
      }
      public var hasPriority:Bool {
           get {
                return builderResult.hasPriority
           }
      }
      public var priority:UInt32 {
           get {
                return builderResult.priority
           }
           set (value) {
               builderResult.hasPriority = true
               builderResult.priority = value
           }
      }
      public func setPriority(value:UInt32) -> Apple.Apns.ProviderData.Builder {
        self.priority = value
        return self
      }
      public func clearPriority() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasPriority = false
           builderResult.priority = UInt32(0)
           return self
      }
      public var hasPayload:Bool {
           get {
               return builderResult.hasPayload
           }
      }
      public var payload:Apple.Apns.Push! {
           get {
               if payloadBuilder_ != nil {
                  builderResult.payload = payloadBuilder_.getMessage()
               }
               return builderResult.payload
           }
           set (value) {
               builderResult.hasPayload = true
               builderResult.payload = value
           }
      }
      private var payloadBuilder_:Apple.Apns.Push.Builder! {
           didSet {
              builderResult.hasPayload = true
           }
      }
      public func getPayloadBuilder() -> Apple.Apns.Push.Builder {
        if payloadBuilder_ == nil {
           payloadBuilder_ = Apple.Apns.Push.Builder()
           builderResult.payload = payloadBuilder_.getMessage()
           if payload != nil {
              try! payloadBuilder_.mergeFrom(payload)
           }
        }
        return payloadBuilder_
      }
      public func setPayload(value:Apple.Apns.Push!) -> Apple.Apns.ProviderData.Builder {
        self.payload = value
        return self
      }
      public func mergePayload(value:Apple.Apns.Push) throws -> Apple.Apns.ProviderData.Builder {
        if builderResult.hasPayload {
          builderResult.payload = try Apple.Apns.Push.builderWithPrototype(builderResult.payload).mergeFrom(value).buildPartial()
        } else {
          builderResult.payload = value
        }
        builderResult.hasPayload = true
        return self
      }
      public func clearPayload() -> Apple.Apns.ProviderData.Builder {
        payloadBuilder_ = nil
        builderResult.hasPayload = false
        builderResult.payload = nil
        return self
      }
        public var hasServiceIdentity:Bool{
            get {
                return builderResult.hasServiceIdentity
            }
        }
        public var serviceIdentity:Apple.Apns.ProviderData.Identity {
            get {
                return builderResult.serviceIdentity
            }
            set (value) {
                builderResult.hasServiceIdentity = true
                builderResult.serviceIdentity = value
            }
        }
        public func setServiceIdentity(value:Apple.Apns.ProviderData.Identity) -> Apple.Apns.ProviderData.Builder {
          self.serviceIdentity = value
          return self
        }
        public func clearServiceIdentity() -> Apple.Apns.ProviderData.Builder {
           builderResult.hasServiceIdentity = false
           builderResult.serviceIdentity = .Production
           return self
        }
      public var hasCertificateName:Bool {
           get {
                return builderResult.hasCertificateName
           }
      }
      public var certificateName:String {
           get {
                return builderResult.certificateName
           }
           set (value) {
               builderResult.hasCertificateName = true
               builderResult.certificateName = value
           }
      }
      public func setCertificateName(value:String) -> Apple.Apns.ProviderData.Builder {
        self.certificateName = value
        return self
      }
      public func clearCertificateName() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasCertificateName = false
           builderResult.certificateName = ""
           return self
      }
      public var hasCertificatePassphrase:Bool {
           get {
                return builderResult.hasCertificatePassphrase
           }
      }
      public var certificatePassphrase:String {
           get {
                return builderResult.certificatePassphrase
           }
           set (value) {
               builderResult.hasCertificatePassphrase = true
               builderResult.certificatePassphrase = value
           }
      }
      public func setCertificatePassphrase(value:String) -> Apple.Apns.ProviderData.Builder {
        self.certificatePassphrase = value
        return self
      }
      public func clearCertificatePassphrase() -> Apple.Apns.ProviderData.Builder{
           builderResult.hasCertificatePassphrase = false
           builderResult.certificatePassphrase = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Apple.Apns.ProviderData.Builder {
        builderResult = Apple.Apns.ProviderData()
        return self
      }
      override public func clone() throws -> Apple.Apns.ProviderData.Builder {
        return try Apple.Apns.ProviderData.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Apple.Apns.ProviderData {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.ProviderData {
        let returnMe:Apple.Apns.ProviderData = builderResult
        return returnMe
      }
      public func mergeFrom(other:Apple.Apns.ProviderData) throws -> Apple.Apns.ProviderData.Builder {
        if other == Apple.Apns.ProviderData() {
         return self
        }
        if other.hasBundle {
             bundle = other.bundle
        }
        if other.hasToken {
             token = other.token
        }
        if other.hasPriority {
             priority = other.priority
        }
        if (other.hasPayload) {
            try mergePayload(other.payload)
        }
        if other.hasServiceIdentity {
             serviceIdentity = other.serviceIdentity
        }
        if other.hasCertificateName {
             certificateName = other.certificateName
        }
        if other.hasCertificatePassphrase {
             certificatePassphrase = other.certificatePassphrase
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.ProviderData.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.ProviderData.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            bundle = try input.readString()

          case 18 :
            token = try input.readString()

          case 24 :
            priority = try input.readUInt32()

          case 34 :
            let subBuilder:Apple.Apns.Push.Builder = Apple.Apns.Push.Builder()
            if hasPayload {
              try subBuilder.mergeFrom(payload)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            payload = subBuilder.buildPartial()

          case 40 :
            let valueIntserviceIdentity = try input.readEnum()
            if let enumsserviceIdentity = Apple.Apns.ProviderData.Identity(rawValue:valueIntserviceIdentity){
                 serviceIdentity = enumsserviceIdentity
            } else {
                 try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntserviceIdentity))
            }

          case 50 :
            certificateName = try input.readString()

          case 58 :
            certificatePassphrase = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.ProviderData.Builder {
        let resultDecodedBuilder = Apple.Apns.ProviderData.Builder()
        if let jsonValueBundle = jsonMap["bundle"] as? String {
          resultDecodedBuilder.bundle = jsonValueBundle
        }
        if let jsonValueToken = jsonMap["token"] as? String {
          resultDecodedBuilder.token = jsonValueToken
        }
        if let jsonValuePriority = jsonMap["priority"] as? NSNumber {
          resultDecodedBuilder.priority = jsonValuePriority.unsignedIntValue
        }
        if let jsonValuePayload = jsonMap["payload"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.payload = try Apple.Apns.Push.Builder.decodeToBuilder(jsonValuePayload).build()

        }
        if let jsonValueServiceIdentity = jsonMap["serviceIdentity"] as? String {
          resultDecodedBuilder.serviceIdentity = try Apple.Apns.ProviderData.Identity.fromString(jsonValueServiceIdentity)
        }
        if let jsonValueCertificateName = jsonMap["certificateName"] as? String {
          resultDecodedBuilder.certificateName = jsonValueCertificateName
        }
        if let jsonValueCertificatePassphrase = jsonMap["certificatePassphrase"] as? String {
          resultDecodedBuilder.certificatePassphrase = jsonValueCertificatePassphrase
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Apple.Apns.ProviderData.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.ProviderData.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class Response : GeneratedMessage, GeneratedMessageProtocol {
    //200 - Success
    //400 - Bad request
    //403 - There was an error with the certificate.
    //405 - The request used a bad :method value. Only POST requests are supported.
    //410 - The device token is no longer active for the topic.
    //413 - The notification payload was too large.
    //429 - The server received too many requests for the same device token. 
    //500 - Internal server error
    //503 - The server is shutting down and unavailable.
    public private(set) var hasStatusCode:Bool = false
    public private(set) var statusCode:Int32 = Int32(0)

    public private(set) var hasApnsId:Bool = false
    public private(set) var apnsId:String = ""

    public private(set) var hasReason:Bool = false
    public private(set) var reason:String = ""

    public private(set) var hasReasonDescription:Bool = false
    public private(set) var reasonDescription:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStatusCode {
        try output.writeInt32(1, value:statusCode)
      }
      if hasApnsId {
        try output.writeString(2, value:apnsId)
      }
      if hasReason {
        try output.writeString(3, value:reason)
      }
      if hasReasonDescription {
        try output.writeString(4, value:reasonDescription)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasStatusCode {
        serialize_size += statusCode.computeInt32Size(1)
      }
      if hasApnsId {
        serialize_size += apnsId.computeStringSize(2)
      }
      if hasReason {
        serialize_size += reason.computeStringSize(3)
      }
      if hasReasonDescription {
        serialize_size += reasonDescription.computeStringSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Apple.Apns.Response> {
      var mergedArray = Array<Apple.Apns.Response>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Apple.Apns.Response? {
      return try Apple.Apns.Response.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromData(data, extensionRegistry:Apple.Apns.PushServiceRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Apple.Apns.Response.Builder {
      return Apple.Apns.Response.classBuilder() as! Apple.Apns.Response.Builder
    }
    public func getBuilder() -> Apple.Apns.Response.Builder {
      return classBuilder() as! Apple.Apns.Response.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Apple.Apns.Response.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Apple.Apns.Response.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.Response.Builder {
      return try Apple.Apns.Response.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.Response) throws -> Apple.Apns.Response.Builder {
      return try Apple.Apns.Response.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasStatusCode {
        jsonMap["statusCode"] = NSNumber(int:statusCode)
      }
      if hasApnsId {
        jsonMap["apnsId"] = apnsId
      }
      if hasReason {
        jsonMap["reason"] = reason
      }
      if hasReasonDescription {
        jsonMap["reasonDescription"] = reasonDescription
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Apple.Apns.Response {
      return try Apple.Apns.Response.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasStatusCode {
        output += "\(indent) statusCode: \(statusCode) \n"
      }
      if hasApnsId {
        output += "\(indent) apnsId: \(apnsId) \n"
      }
      if hasReason {
        output += "\(indent) reason: \(reason) \n"
      }
      if hasReasonDescription {
        output += "\(indent) reasonDescription: \(reasonDescription) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatusCode {
               hashCode = (hashCode &* 31) &+ statusCode.hashValue
            }
            if hasApnsId {
               hashCode = (hashCode &* 31) &+ apnsId.hashValue
            }
            if hasReason {
               hashCode = (hashCode &* 31) &+ reason.hashValue
            }
            if hasReasonDescription {
               hashCode = (hashCode &* 31) &+ reasonDescription.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.Response"
    }
    override public func className() -> String {
        return "Apple.Apns.Response"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Apple.Apns.Response.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Apple.Apns.Response = Apple.Apns.Response()
      public func getMessage() -> Apple.Apns.Response {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasStatusCode:Bool {
           get {
                return builderResult.hasStatusCode
           }
      }
      public var statusCode:Int32 {
           get {
                return builderResult.statusCode
           }
           set (value) {
               builderResult.hasStatusCode = true
               builderResult.statusCode = value
           }
      }
      public func setStatusCode(value:Int32) -> Apple.Apns.Response.Builder {
        self.statusCode = value
        return self
      }
      public func clearStatusCode() -> Apple.Apns.Response.Builder{
           builderResult.hasStatusCode = false
           builderResult.statusCode = Int32(0)
           return self
      }
      public var hasApnsId:Bool {
           get {
                return builderResult.hasApnsId
           }
      }
      public var apnsId:String {
           get {
                return builderResult.apnsId
           }
           set (value) {
               builderResult.hasApnsId = true
               builderResult.apnsId = value
           }
      }
      public func setApnsId(value:String) -> Apple.Apns.Response.Builder {
        self.apnsId = value
        return self
      }
      public func clearApnsId() -> Apple.Apns.Response.Builder{
           builderResult.hasApnsId = false
           builderResult.apnsId = ""
           return self
      }
      public var hasReason:Bool {
           get {
                return builderResult.hasReason
           }
      }
      public var reason:String {
           get {
                return builderResult.reason
           }
           set (value) {
               builderResult.hasReason = true
               builderResult.reason = value
           }
      }
      public func setReason(value:String) -> Apple.Apns.Response.Builder {
        self.reason = value
        return self
      }
      public func clearReason() -> Apple.Apns.Response.Builder{
           builderResult.hasReason = false
           builderResult.reason = ""
           return self
      }
      public var hasReasonDescription:Bool {
           get {
                return builderResult.hasReasonDescription
           }
      }
      public var reasonDescription:String {
           get {
                return builderResult.reasonDescription
           }
           set (value) {
               builderResult.hasReasonDescription = true
               builderResult.reasonDescription = value
           }
      }
      public func setReasonDescription(value:String) -> Apple.Apns.Response.Builder {
        self.reasonDescription = value
        return self
      }
      public func clearReasonDescription() -> Apple.Apns.Response.Builder{
           builderResult.hasReasonDescription = false
           builderResult.reasonDescription = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Apple.Apns.Response.Builder {
        builderResult = Apple.Apns.Response()
        return self
      }
      override public func clone() throws -> Apple.Apns.Response.Builder {
        return try Apple.Apns.Response.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Apple.Apns.Response {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.Response {
        let returnMe:Apple.Apns.Response = builderResult
        return returnMe
      }
      public func mergeFrom(other:Apple.Apns.Response) throws -> Apple.Apns.Response.Builder {
        if other == Apple.Apns.Response() {
         return self
        }
        if other.hasStatusCode {
             statusCode = other.statusCode
        }
        if other.hasApnsId {
             apnsId = other.apnsId
        }
        if other.hasReason {
             reason = other.reason
        }
        if other.hasReasonDescription {
             reasonDescription = other.reasonDescription
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Response.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Response.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            statusCode = try input.readInt32()

          case 18 :
            apnsId = try input.readString()

          case 26 :
            reason = try input.readString()

          case 34 :
            reasonDescription = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Response.Builder {
        let resultDecodedBuilder = Apple.Apns.Response.Builder()
        if let jsonValueStatusCode = jsonMap["statusCode"] as? NSNumber {
          resultDecodedBuilder.statusCode = jsonValueStatusCode.intValue
        }
        if let jsonValueApnsId = jsonMap["apnsId"] as? String {
          resultDecodedBuilder.apnsId = jsonValueApnsId
        }
        if let jsonValueReason = jsonMap["reason"] as? String {
          resultDecodedBuilder.reason = jsonValueReason
        }
        if let jsonValueReasonDescription = jsonMap["reasonDescription"] as? String {
          resultDecodedBuilder.reasonDescription = jsonValueReasonDescription
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Apple.Apns.Response.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.Response.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class Push : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class Aps : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasAlert:Bool = false
        public private(set) var alert:String = ""

        public private(set) var hasSound:Bool = false
        public private(set) var sound:String = ""

        public private(set) var hasBadge:Bool = false
        public private(set) var badge:Int32 = Int32(0)

        public private(set) var hasContentAvailable:Bool = false
        public private(set) var contentAvailable:Int32 = Int32(0)

        public private(set) var hasCategory:Bool = false
        public private(set) var category:String = ""

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasAlert {
            try output.writeString(1, value:alert)
          }
          if hasSound {
            try output.writeString(2, value:sound)
          }
          if hasBadge {
            try output.writeInt32(3, value:badge)
          }
          if hasContentAvailable {
            try output.writeInt32(4, value:contentAvailable)
          }
          if hasCategory {
            try output.writeString(5, value:category)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasAlert {
            serialize_size += alert.computeStringSize(1)
          }
          if hasSound {
            serialize_size += sound.computeStringSize(2)
          }
          if hasBadge {
            serialize_size += badge.computeInt32Size(3)
          }
          if hasContentAvailable {
            serialize_size += contentAvailable.computeInt32Size(4)
          }
          if hasCategory {
            serialize_size += category.computeStringSize(5)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Apple.Apns.Push.Aps> {
          var mergedArray = Array<Apple.Apns.Push.Aps>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Apple.Apns.Push.Aps? {
          return try Apple.Apns.Push.Aps.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromData(data, extensionRegistry:Apple.Apns.PushServiceRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Apple.Apns.Push.Aps.Builder {
          return Apple.Apns.Push.Aps.classBuilder() as! Apple.Apns.Push.Aps.Builder
        }
        public func getBuilder() -> Apple.Apns.Push.Aps.Builder {
          return classBuilder() as! Apple.Apns.Push.Aps.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Apple.Apns.Push.Aps.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Apple.Apns.Push.Aps.Builder()
        }
        public func toBuilder() throws -> Apple.Apns.Push.Aps.Builder {
          return try Apple.Apns.Push.Aps.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Aps.Builder {
          return try Apple.Apns.Push.Aps.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasAlert {
            jsonMap["alert"] = alert
          }
          if hasSound {
            jsonMap["sound"] = sound
          }
          if hasBadge {
            jsonMap["badge"] = NSNumber(int:badge)
          }
          if hasContentAvailable {
            jsonMap["contentAvailable"] = NSNumber(int:contentAvailable)
          }
          if hasCategory {
            jsonMap["category"] = category
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> Apple.Apns.Push.Aps {
          return try Apple.Apns.Push.Aps.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasAlert {
            output += "\(indent) alert: \(alert) \n"
          }
          if hasSound {
            output += "\(indent) sound: \(sound) \n"
          }
          if hasBadge {
            output += "\(indent) badge: \(badge) \n"
          }
          if hasContentAvailable {
            output += "\(indent) contentAvailable: \(contentAvailable) \n"
          }
          if hasCategory {
            output += "\(indent) category: \(category) \n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasAlert {
                   hashCode = (hashCode &* 31) &+ alert.hashValue
                }
                if hasSound {
                   hashCode = (hashCode &* 31) &+ sound.hashValue
                }
                if hasBadge {
                   hashCode = (hashCode &* 31) &+ badge.hashValue
                }
                if hasContentAvailable {
                   hashCode = (hashCode &* 31) &+ contentAvailable.hashValue
                }
                if hasCategory {
                   hashCode = (hashCode &* 31) &+ category.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Apple.Apns.Push.Aps"
        }
        override public func className() -> String {
            return "Apple.Apns.Push.Aps"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Apple.Apns.Push.Aps.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Apple.Apns.Push.Aps = Apple.Apns.Push.Aps()
          public func getMessage() -> Apple.Apns.Push.Aps {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasAlert:Bool {
               get {
                    return builderResult.hasAlert
               }
          }
          public var alert:String {
               get {
                    return builderResult.alert
               }
               set (value) {
                   builderResult.hasAlert = true
                   builderResult.alert = value
               }
          }
          public func setAlert(value:String) -> Apple.Apns.Push.Aps.Builder {
            self.alert = value
            return self
          }
          public func clearAlert() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasAlert = false
               builderResult.alert = ""
               return self
          }
          public var hasSound:Bool {
               get {
                    return builderResult.hasSound
               }
          }
          public var sound:String {
               get {
                    return builderResult.sound
               }
               set (value) {
                   builderResult.hasSound = true
                   builderResult.sound = value
               }
          }
          public func setSound(value:String) -> Apple.Apns.Push.Aps.Builder {
            self.sound = value
            return self
          }
          public func clearSound() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasSound = false
               builderResult.sound = ""
               return self
          }
          public var hasBadge:Bool {
               get {
                    return builderResult.hasBadge
               }
          }
          public var badge:Int32 {
               get {
                    return builderResult.badge
               }
               set (value) {
                   builderResult.hasBadge = true
                   builderResult.badge = value
               }
          }
          public func setBadge(value:Int32) -> Apple.Apns.Push.Aps.Builder {
            self.badge = value
            return self
          }
          public func clearBadge() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasBadge = false
               builderResult.badge = Int32(0)
               return self
          }
          public var hasContentAvailable:Bool {
               get {
                    return builderResult.hasContentAvailable
               }
          }
          public var contentAvailable:Int32 {
               get {
                    return builderResult.contentAvailable
               }
               set (value) {
                   builderResult.hasContentAvailable = true
                   builderResult.contentAvailable = value
               }
          }
          public func setContentAvailable(value:Int32) -> Apple.Apns.Push.Aps.Builder {
            self.contentAvailable = value
            return self
          }
          public func clearContentAvailable() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasContentAvailable = false
               builderResult.contentAvailable = Int32(0)
               return self
          }
          public var hasCategory:Bool {
               get {
                    return builderResult.hasCategory
               }
          }
          public var category:String {
               get {
                    return builderResult.category
               }
               set (value) {
                   builderResult.hasCategory = true
                   builderResult.category = value
               }
          }
          public func setCategory(value:String) -> Apple.Apns.Push.Aps.Builder {
            self.category = value
            return self
          }
          public func clearCategory() -> Apple.Apns.Push.Aps.Builder{
               builderResult.hasCategory = false
               builderResult.category = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Apple.Apns.Push.Aps.Builder {
            builderResult = Apple.Apns.Push.Aps()
            return self
          }
          override public func clone() throws -> Apple.Apns.Push.Aps.Builder {
            return try Apple.Apns.Push.Aps.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Apple.Apns.Push.Aps {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Apple.Apns.Push.Aps {
            let returnMe:Apple.Apns.Push.Aps = builderResult
            return returnMe
          }
          public func mergeFrom(other:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Aps.Builder {
            if other == Apple.Apns.Push.Aps() {
             return self
            }
            if other.hasAlert {
                 alert = other.alert
            }
            if other.hasSound {
                 sound = other.sound
            }
            if other.hasBadge {
                 badge = other.badge
            }
            if other.hasContentAvailable {
                 contentAvailable = other.contentAvailable
            }
            if other.hasCategory {
                 category = other.category
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Push.Aps.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Aps.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10 :
                alert = try input.readString()

              case 18 :
                sound = try input.readString()

              case 24 :
                badge = try input.readInt32()

              case 32 :
                contentAvailable = try input.readInt32()

              case 42 :
                category = try input.readString()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Push.Aps.Builder {
            let resultDecodedBuilder = Apple.Apns.Push.Aps.Builder()
            if let jsonValueAlert = jsonMap["alert"] as? String {
              resultDecodedBuilder.alert = jsonValueAlert
            }
            if let jsonValueSound = jsonMap["sound"] as? String {
              resultDecodedBuilder.sound = jsonValueSound
            }
            if let jsonValueBadge = jsonMap["badge"] as? NSNumber {
              resultDecodedBuilder.badge = jsonValueBadge.intValue
            }
            if let jsonValueContentAvailable = jsonMap["contentAvailable"] as? NSNumber {
              resultDecodedBuilder.contentAvailable = jsonValueContentAvailable.intValue
            }
            if let jsonValueCategory = jsonMap["category"] as? String {
              resultDecodedBuilder.category = jsonValueCategory
            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> Apple.Apns.Push.Aps.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public private(set) var hasAps:Bool = false
    public private(set) var aps:Apple.Apns.Push.Aps!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasAps {
        try output.writeMessage(1, value:aps)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasAps {
          if let varSizeaps = aps?.computeMessageSize(1) {
              serialize_size += varSizeaps
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Apple.Apns.Push> {
      var mergedArray = Array<Apple.Apns.Push>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Apple.Apns.Push? {
      return try Apple.Apns.Push.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromData(data, extensionRegistry:Apple.Apns.PushServiceRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Apple.Apns.Push.Builder {
      return Apple.Apns.Push.classBuilder() as! Apple.Apns.Push.Builder
    }
    public func getBuilder() -> Apple.Apns.Push.Builder {
      return classBuilder() as! Apple.Apns.Push.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Apple.Apns.Push.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Apple.Apns.Push.Builder()
    }
    public func toBuilder() throws -> Apple.Apns.Push.Builder {
      return try Apple.Apns.Push.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Apple.Apns.Push) throws -> Apple.Apns.Push.Builder {
      return try Apple.Apns.Push.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasAps {
        jsonMap["aps"] = try aps.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Apple.Apns.Push {
      return try Apple.Apns.Push.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasAps {
        output += "\(indent) aps {\n"
        if let outDescAps = aps {
          output += try outDescAps.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasAps {
                if let hashValueaps = aps?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaps
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Apple.Apns.Push"
    }
    override public func className() -> String {
        return "Apple.Apns.Push"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Apple.Apns.Push.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Apple.Apns.Push = Apple.Apns.Push()
      public func getMessage() -> Apple.Apns.Push {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasAps:Bool {
           get {
               return builderResult.hasAps
           }
      }
      public var aps:Apple.Apns.Push.Aps! {
           get {
               if apsBuilder_ != nil {
                  builderResult.aps = apsBuilder_.getMessage()
               }
               return builderResult.aps
           }
           set (value) {
               builderResult.hasAps = true
               builderResult.aps = value
           }
      }
      private var apsBuilder_:Apple.Apns.Push.Aps.Builder! {
           didSet {
              builderResult.hasAps = true
           }
      }
      public func getApsBuilder() -> Apple.Apns.Push.Aps.Builder {
        if apsBuilder_ == nil {
           apsBuilder_ = Apple.Apns.Push.Aps.Builder()
           builderResult.aps = apsBuilder_.getMessage()
           if aps != nil {
              try! apsBuilder_.mergeFrom(aps)
           }
        }
        return apsBuilder_
      }
      public func setAps(value:Apple.Apns.Push.Aps!) -> Apple.Apns.Push.Builder {
        self.aps = value
        return self
      }
      public func mergeAps(value:Apple.Apns.Push.Aps) throws -> Apple.Apns.Push.Builder {
        if builderResult.hasAps {
          builderResult.aps = try Apple.Apns.Push.Aps.builderWithPrototype(builderResult.aps).mergeFrom(value).buildPartial()
        } else {
          builderResult.aps = value
        }
        builderResult.hasAps = true
        return self
      }
      public func clearAps() -> Apple.Apns.Push.Builder {
        apsBuilder_ = nil
        builderResult.hasAps = false
        builderResult.aps = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Apple.Apns.Push.Builder {
        builderResult = Apple.Apns.Push()
        return self
      }
      override public func clone() throws -> Apple.Apns.Push.Builder {
        return try Apple.Apns.Push.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Apple.Apns.Push {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Apple.Apns.Push {
        let returnMe:Apple.Apns.Push = builderResult
        return returnMe
      }
      public func mergeFrom(other:Apple.Apns.Push) throws -> Apple.Apns.Push.Builder {
        if other == Apple.Apns.Push() {
         return self
        }
        if (other.hasAps) {
            try mergeAps(other.aps)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Apple.Apns.Push.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Apple.Apns.Push.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10 :
            let subBuilder:Apple.Apns.Push.Aps.Builder = Apple.Apns.Push.Aps.Builder()
            if hasAps {
              try subBuilder.mergeFrom(aps)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            aps = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Apple.Apns.Push.Builder {
        let resultDecodedBuilder = Apple.Apns.Push.Builder()
        if let jsonValueAps = jsonMap["aps"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.aps = try Apple.Apns.Push.Aps.Builder.decodeToBuilder(jsonValueAps).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Apple.Apns.Push.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Apple.Apns.Push.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
